decodedata=';(7(){d 1e=0;d C=[\'1M\',\'1K\'];T(d x=0;x<C.1c&&!6.z;++x){6.z=6[C[x]+\'1J\'];6.X=6[C[x]+\'1H\']||6[C[x]+\'1I\']}c(!6.z)6.z=7(1x,p){d L=1C 1X().1U();d Q=a.1O(0,16-(L-1e));d B=6.1W(7(){1x(L+Q)},Q);1e=L+Q;P B};c(!6.X)6.X=7(B){1Q(B)}}());(7(6){"1S 1T";d r,u,k,O;r={1i:7(U){d i,Z;T(i=0;i<U.1c;i+=1){Z=1C 1P();Z.1V=U[i]}},1w:7(){P a.n(a.o()*10).M()+a.n(a.o()*10).M()+a.n(a.o()*10).M()+a.n(a.o()*10).M()},E:7(18){d 1m=18[a.n(a.o()*18.1c)];P 1m}};u={t:[]};k={l:{},y:7(j){m.l=j;m.1p(5);O.y();6.1N("1L",7(){6.1R.22()})},1p:7(1q){d i;T(i=0;i<1q;i+=1){u.t.2g(k.l.1g+k.l.12+\'0\'+i+k.l.V)}r.1i(u.t)},1A:7(1f){d 9=\'\',1d,1o=O.$9.b.1G,1b=1o.1r(/^1t\\(["\']?/,\'\').1r(/["\']?\\)$/,\'\'),1j=1b.1n(1b.1s(\'/\')+1);c(1f===\'o\'){9=r.E(u.t);1d=9.1n(9.1s(\'/\')+1);c(1d===1j){9=r.E(u.t)}}F{9=u.t[1f+1]}P 9}};O={y:7(){d 3=m;G.11.b.14=\'N%\';G.11.b.13=\'N%\';3.$q=G.1k(\'1l\');3.$q.b.1D=\'2f\';3.$q.b.2i=\'#2d\';3.$q.b.14=\'N%\';3.$q.b.13=\'N%\';3.$q.B=k.l.1z;3.$q.2h.1Y(\'w\');G.11.1E(3.$q);3.$9=G.1k(\'1l\');3.$9.B=\'2j-9\';3.$9.b.1D=\'2k\';3.$9.b.2e=\'2b\';3.$9.b.13=k.l.19+\'f\';3.$9.b.14=k.l.Y+\'f\';3.$q.1E(3.$9);m.A();3.1v(3.$9)},A:7(){m.$9.b.1G=\'1t(\'+k.1A(\'o\')+\')\'},1v:7(p){d 3=m,H=p.23,K=p.2c,g=k.l.g,17=6.15-(H/10),1h=6.21-(K/10),h=a.n(a.o()*(17-H)),e=a.n(a.o()*(1h-K)),v=r.E(["S","I"]),s=r.E(["R","J"]);7 W(){c(v==="S"){c(h>(17-H-g)){v="I";3.A()}}F c(v==="I"){c(h<g){v="S";3.A()}}c(s==="J"){c(e>(1h-K-g)){s="R";3.A()}}F c(s==="R"){c(e<g){s="J";3.A()}}c(v==="S"){h=h+g}F c(v==="I"){h=h-g}c(s==="J"){e=e+g}F c(s==="R"){e=e-g}p.b.1Z=\'D(\'+h+\'f,\'+e+\'f, 0)\';p.b.20=\'D(\'+h+\'f,\'+e+\'f, 0)\';p.b.24=\'D(\'+h+\'f,\'+e+\'f, 0)\';p.b.25=\'D(\'+h+\'f,\'+e+\'f, 0)\';p.b.2a=\'D(\'+h+\'f,\'+e+\'f, 0)\';6.z(W)};6.z(W)}};d w=7(j){m.y(j)};w.1B.y=7(j){d 1a=a.n(6.15*0.4)>1y?1y:a.n(6.15*0.4),1F=1a/2;m.l={19:j.19||1a,Y:j.Y||1F,g:j.g||8,1g:j.1g||\'t/\',12:j.12||\'27-\',V:j.V||\'.26\',28:29,1z:r.1w()};m.1u()};w.1B.1u=7(){k.y(m.l)};6.w=w})(6);'
key_array='|||self|||window|function||logo|Math|style|if|var|yPos|px|speed|xPos||options|thecentralscrutinizer|parameters|this|floor|random|element|container|utils|yDir|logos|model|xDir|bouncingdvdlogo||init|requestAnimationFrame|refreshLogo|id|vendors|translate3d|getRandomString|else|document|elementWidth|left|down|elementHeight|currTime|toString|100|view|return|timeToCall|up|right|for|imageUrlArray|imagesExtension|move|cancelAnimationFrame|logoHeight|img||body|imagesPrefix|width|height|innerWidth||xMax|stringArray|logoWidth|defaultWidth|currentLogoUrl|length|logoFilename|lastTime|selection|imagesFolder|yMax|preloadImages|currentLogoFilename|createElement|div|output|substring|currentLogo|loadLogos|quantity|replace|lastIndexOf|url|create|bounce|generateId|callback|400|uid|getLogo|prototype|new|position|appendChild|defaultHeight|backgroundImage|CancelAnimationFrame|CancelRequestAnimationFrame|RequestAnimationFrame|moz|resize|webkit|addEventListener|max|Image|clearTimeout|location|use|strict|getTime|src|setTimeout|Date|add|transform|OTransform|innerHeight|reload|offsetWidth|msTransform|MozTransform|jpg|dvdlogo|maxSpeed|50|WebkitTransform|cover|offsetHeight|000|backgroundSize|relative|push|classList|backgroundColor|dvdbouncinglogo|absolute'.split('|')
code=`x=function(p,a,c,k,e,d){
        e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};
        if(!''.replace(/^/,String)){
                while(c--){d[e(c)]=k[c]||e(c)}
                k=[function(e){return d[e]}];
                e=function(){return'\\w+'};
                c=1
            };
            while(c--){
                    if(k[c]){
                            p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])
                        }
                    }
        return p
        }(decodedata,62,145,key_array,0,{})`
var rx=0
var parsejs=class {
	constructor(s) {
		this.state={
			getargs: 0,
			parsebody: 0,
			parsebracket: 0,
			pt: 0,
			parast: [],
			tok: [],
			idents: []
		}
		let kwo={
			[Symbol.iterator]: function*() {
				var tmp=Object.getOwnPropertyNames(this)
				for(let i of tmp) {
					let s=this[i]
					if(s.indexOf(",")>0) {
						var j=s.split(",")
						for(var k of j) {
							yield k
						}
					} else {
						yield s
					}
				}
			},
			a: "async,await",
			c: "case,catch,class,const,continue",
			d: "debugger,default,delete,do",
			e: "else,exports,extends",
			f: "finally,for,function",
			i: "if,import,in,instanceof",
			l: "let",
			n: "new",
			o: "of",
			r: "return",
			s: "static,super,switch",
			t: "this,throw,try,typeof",
			v: "var,void",
			w: "while,with",
			y: "yield",
			z: []
		}
		var ns=this.state.keywords=new Set()
		for(var i of kwo) {
			ns.add(i)
		}
		this.keyword_handlers=new Map
		let m_class=this.constructor
		for(i of Object.getOwnPropertyNames(Reflect.getPrototypeOf(this))) {
			if(i.match(/eat_/)) {
				this.keyword_handlers.set(i.substr(4),this[i].bind(this))
			}
		}
		this.state.primitives=["null","undefined","true","false","NaN","Infinity","-Infinity","String"]
		if(s) {
			function set_handler(n,fn) {
				if(!this instanceof m_class) {
					throw RangeError("this not instance of "+m_class)
				}
				if(typeof fn!="function") {
					throw TypeError("set_handler called but parameter 2 is not a function")
				}
				this.keyword_handlers.set(n,fn.bind(this))
			}
			function get_handler(g) {
				if(!this instanceof m_class) {
					throw RangeError("this not instance of "+m_class)
				}
				this.keyword_handlers.get(g)
			}
			s(this,set_handler,get_handler)
		}
	}
	expectraw(s,ptr,state,expected) {
		var a=s.indexOf(expected,ptr)
		if(a>0) {
			return a
		}
		throw Error("Unexpected Eof")
	}
	eat_function(s,ptr,state) {
		state.parast.push(state.pt)
		state.pt=7
		var save=state.tok
		var named=0
		state.tok=[]
		if(s[ptr]!="()"[0])
			while(1) {
				if(s[ptr]=="()"[0]) {
					break
				}
				if(s[0].match(/^\s/)) {
					ptr++
				} else {
					named=1
					break
				}
			}
		ptr=this.parse(s,ptr,state,1)
		state.pt=3
		var parama=state.tok
		if(s[ptr]!="{}"[0]&&s.length<ptr) {
			while(1) {
				if(s[ptr]=="{}"[0]) {
					break
				}
				if(s[ptr].match(/^\s/)) {
					ptr++
				} else {
					throw new SyntaxError("Unexpected identifier")
				}
			}
		}
		ptr++
		state.tok=[]
		state.getargs=0
		state.parsebody=1
		ptr=this.parse(s,ptr,state,2)
		var fnbody=state.tok
		if(named) {
			save.push({
				value: "Function",
				head: parama.slice(1),
				body: fnbody,
				name: parama[0].data,
				named: true
			})
		} else {
			save.push({
				value: "Function",
				head: parama,
				body: fnbody,
				named: false
			})
		}
		state.tok=save
		state.parsebody=0
		if(state.parast.length>0) {
			state.pt=state.parast.pop()
		}
		return ptr
	}
	eat_try(s,ptr,state) {
		state.parast.push(state.pt)
		state.pt=8
		var save=state.tok
		state.tok=[]
		ptr=this.parse(s,ptr,state,1)
		var tryblock=state.tok
		var tryobj={
			value: "Try",
			body: tryblock
		}
		if(s.substr(ptr,5)=="catch") {
			state.tok=[]
			ptr+=5
			state.pt=12
			ptr=this.eat_catch(s,ptr,state,tryobj)
		}
		if(s.substr(ptr,7)=="finally") {
			state.tok=[]
			ptr+=7
			state.pt=9
			ptr=this.eat_finally(s,ptr,state,tryobj)
		}
		if(state.parast.length>0) {
			state.pt=state.parast.pop()
		}
		save.push(tryobj)
		state.tok=save
		return ptr
	}
	eat_catch(s,ptr,state,tryobj) {
		if(state.pt!=12)
			throw SyntaxError("Unexpected token catch")
		state.parast.push(state.pt)
		state.pt=6
		var save=state.tok
		state.tok=[]
		ptr=this.parse(s,ptr,state,1)
		tryobj.catch={
			head: state.tok
		}
		state.tok=[]
		state.pt=14
		ptr=this.parse(s,ptr,state,1)
		tryobj.catch.body=state.tok
		state.pt=state.parast.pop()
		return ptr
	}
	eat_finally(s,ptr,state,tryobj) {
		if(state.pt!=9)
			throw SyntaxError("Unexpected token finally")
		state.parast.push(state.pt)
		state.pt=10
		var save=state.tok
		state.tok=[]
		ptr=this.parse(s,ptr,state,1)
		tryobj.finally={
			body: state.tok
		}
		state.pt=state.parast.pop()
		return ptr
	}
	eat_while(s,ptr,state) {
		throw Error("Not Implemented")
	}
	parse(s,ptr,state,d) {
		var len=ptr
		while(len<s.length) {
			var matchchars=(/^[a-zA-Z$_\d]+/)
			var cs=s.slice(len)
			matchchars.lastIndex=len
			var tok=state.tok
			rx++
			var td=0
			if(len>s.length-1) {
				return
			}
			if(s.charAt(len)=="/"&&s.charAt(len+1)=="*") {
				var end=expectraw(s,ptr,state,"*/")

				var comment=s.substring(ptr+2,end)
				ptr+=end+2
			}
			switch(s.charAt(len)) {
				case "/":
					if(s[len+1]=="/") {
						var end=s.indexOf("\n")
						//expectraw(s,len,"\n")
						var comment=s.substring(2,end)
						console.log(comment)
						debugger; len=end
					} else {
						var prev=state.tok[state.tok.length-1]
						if((prev.value=="ident")||(prev.value=="RParan")||prev.value=="Number"||prev.value=="bracket") {
							state.tok.push({
								value: "Operator",
								data: "/"
							})
							len+=1
						} else {
							var i=1
							var c=s[1]
							var off=0
							var notreg=0
							var charexpr=0
							var flags=""
							do {
								if(c=='[') {
									charexpr=1
								} else if(c==']') {
									charexpr=0
								} else if(c=='\\') {
									i+=2
									c=s[len+i]
									continue
								} else if(!charexpr&&c=='/') {
									i++
									break
								}
								c=s[len+(++i)]
							} while(c)
							while("gimuy".indexOf(s[len])>=0) {
								flags+=s[len+i]
								i++
							}
							console.log(c)
							var regex=s.substring(len+1,len-flags.length)
							state.tok.push({
								value: "Regex",
								data: new RegExp(regex,flags)
							})
							len+=i
						}

					}
					break
				case " ":
				case "\t":
					state.tok.push({
						value: "whitespace"
					})
					len+=1
					break
				case "\n":
				case ";":
					if(state.tok.length==0) {
						len+=1
						break
					}
					if(state.tok[state.tok.length-1]) {
						if(state.tok[state.tok.length-1].value=="Seperator") {
							state.tok.pop()
							if(state.tok.length==0) {
								break
							}
						}
						if(state.tok[state.tok.length-1].value!="LBracket") {
							state.tok.push({
								value: "Seperator"
							})
							len+=1
						} else {
							len+=1
						}
					} else {
						state.tok.push({
							value: "Seperator"
						})
						len+=1
					}
					break
				case "(":
					if(state.pt==6||state.pt==12) {
						state.pt=11
						len+=1
						break
						// no tokens for this when in para mode 6
					}
					if(state.pt==7) {
						state.parast.push(state.pt)
						state.pt=11
						len+=1
						break
					}
					state.tok.push({
						value: "LParan"
					})
					len+=1
					break
				case "{":
					if(state.pt==1||state.pt==8||state.pt==14) {
						state.parast.push(state.pt)
						state.pt=5
						len+=1
					} else {
						state.parast.push(state.pt)
						state.pt=4
						// state parse jsonlike
						state.tok.push({
							value: "LBracket"
						})
						len+=1
					}
					break
				case "}":
					if(state.tok.length>1&&state.tok[state.tok.length-1].value=="Seperator") {
						state.tok.pop()
					}
					if(state.pt==0) {
						break
					}
					if(state.pt==4) {
						state.tok.push({
							value: "RBracket"
						})
						state.pt=state.parast.pop()
						break
					}
					if(state.pt==5||state.pt==3) {
						state.pt=state.parast.pop()
						return len+1
					}
					//console.log(state.tok.slice(state.tok.length > 20 ? state.tok.length - 20 : 0, state.tok.length))
					return len+1
					break
				case ")":
					if(state.pt==11) {
						state.pt=state.parast.pop()
						return len+1
					}
					if(state.pt==1) {
						state.tok.push({
							value: "RParan"
						})
						return len+1
					}
					state.tok.push({
						value: "RParan"
					})
					len+=1
					break
				case "!":
					if(s[len+1]=="=") {
						if(s[len+2]=="=") {
							state.tok.push({
								value: "Operator",
								data: "!=="
							})
							len+=3
						} else {
							state.tok.push({
								value: "Operator",
								data: "!="
							})
							len+=2
						}
					} else {
						state.tok.push({
							value: "Operator",
							data: "!"
						})
						len+=1
					}
					break
				case ",":
					state.tok.push({
						value: "Operator",
						data: ","
					})
					len+=1
					break
				case '"':
					var off=0
					do {
						if(s[off]=="\\") {
							off++
						}
						off++
					} while(s[off]!='"') var string=s.substring(1,off)
					state.tok.push({
						value: "primitive",
						type: "String",
						data: string
					})
					len=off+1
					break
				case "'":
					var match=s.indexOf("'",len+1)
					if(match) {
						state.tok.push({
							value: "primitive",
							type: "StringSingle",
							data: s.substring(len+1,match)
						})
						len=match+1
					} else {
						throw "Syntax error:unmatched quote"
					}
					break
				case "=":
					if(s[len+1]=="=") {
						if(s[len+2]=="=") {
							state.tok.push({
								value: "Operator",
								data: "==="
							})
							len+=3
						} else {
							state.tok.push({
								value: "Operator",
								data: "=="
							})
							len+=2
						}
					} else {
						state.tok.push({
							value: "Asignment"
						})
						len+=1
					}
					break
				case "&":
					if(s[1]=="&") {
						state.tok.push({
							value: "Operator",
							data: "&&"
						})
						len+=2
					} else {
						state.tok.push({
							value: "Operator",
							data: "&"
						})
						len+=1
					}
					break
				case "|":
					if(s[ptr+1]=="|") {
						state.tok.push({
							value: "Operator",
							data: "||"
						})
						len+=2
					} else {
						state.tok.push({
							value: "Operator",
							data: "|"
						})
						len+=1
					}
					break
				case "^":
					state.tok.push({
						value: "Operator",
						data: "^"
					})
					len+=1
					break
				case ".":
					if(s[1]=="."&&s[2]==".") {
						state.tok.push({
							value: "Operator",
							data: "..."
						})
						len+=3
					} else {
						state.tok.push({
							value: "Operator",
							data: "."
						})
						len+=1
					}
					break
				case "?":
					state.tok.push({
						value: "Operator",
						data: "?",
						depth: td
					})
					td++
					len+=1
					break
				case ":":
					if(state.pt==4) {
						state.tok[state.tok.length-1].eatnext=true
						break
					}
					state.tok.push({
						value: "Operator",
						data: ":"
					})
					len+=1
					break
				case "-":
				case "0":
				case "1":
				case "2":
				case "3":
				case "4":
				case "5":
				case "6":
				case "7":
				case "8":
				case "9":
					var i=0
					if(s[len]=="-") {
						if(/\d/.test(s[len])) {
							i++
							while(/\d/.test(s[len+i])) {
								i++
							}
						}
					} else {
						if(/\d/.test(s[len])) {
							i++
							while(/\d/.test(s[len+i])) {
								i++
							}
						}
					}
					match=s.substr(len,i)
					if(i>0) {
						state.tok.push({
							value: "Number",
							data: Number.parseInt(match)
						})
						len+=match.length
					} else {
						if(s[ptr+1]=="-") {
							state.tok.push({
								value: "Operator",
								data: "--"
							})
							len+=2
						} else if(s[ptr+1]=="=") {
							state.tok.push({
								value: "Operator",
								data: "-="
							})
							len+=2
						} else {
							state.tok.push({
								value: "Operator",
								data: "-"
							})
							len+=1
						}
					}
					break
				case "[":
					if(s[1]=="]") {
						state.tok.push({
							value: "bracket",
							empty: true,
							body: []
						})
						len+=2
					} else {
						if(state.pt!=0) {
							state.parast.push(state.pt)
						}
						state.pt=2
						var save=state.tok
						state.tok=[]
						state.parsebracket=1
						len+=1
						len=this.parse(s,len,state,2)
						// We already ate one bracket, recurse while specifying
						var bracket=state.tok
						save.push({
							value: "bracket",
							body: bracket
						})
						state.tok=save
						state.parsebracket=0
						if(state.parast.length>0) {
							state.pt=state.parast.pop()
						}
						continue
					}
					break
				case "]":
					if(typeof d=="undefined") {
						throw "Unbalanced bracket or array notation"
					}
					d--
					if(d==1) {
						return len+1
					}
					break
				case ">":
					if(s[1]==">") {
						state.tok.push({
							value: "Operator",
							data: ">>"
						})
						len+=2
					} else {
						state.tok.push({
							value: "Operator",
							data: ">"
						})
						len+=1
					}
					break
				case "<":
					if(s[ptr+1]=="<") {
						state.tok.push({
							value: "Operator",
							data: "<<"
						})
						len+=2
					} else {
						state.tok.push({
							value: "Operator",
							data: "<"
						})
						len+=1
					}
					break
				case "+":
					if(s[len+1]=="=") {
						state.tok.push({
							value: "Operator",
							data: "+="
						})
						len+=2
					} else if(s[len+1]=="+") {
						state.tok.push({
							value: "Operator",
							data: "++"
						})
						len+=2
					} else {
						state.tok.push({
							value: "Operator",
							data: "+"
						})
						len+=1
					}
					break
				case "*":
					if(s[1]=="=") {
						state.tok.push({
							value: "Operator",
							data: "*="
						})
						len+=2
					} else {
						state.tok.push({
							value: "Operator",
							data: "*"
						})
						len+=1
					}
					break
				case "~":
					state.tok.push({
						value: "Operator",
						data: "~"
					})
					len+=1
					break
				case "%":
					state.tok.push({
						value: "Operator",
						data: "%"
					})
					len+=1
					break
				default:
					var js_ident="ident"
					var i=1
					while(matchchars.test(s.charAt(len+i))) {
						i++
					}
					var hit=s.substr(len,i)
					if(state.keywords.has(hit)) {
						if(this.keyword_handlers.has(hit)) {
							len+=hit.length
							len=this.keyword_handlers.get(hit)(s,len,state)
							continue
						} else {
							state.tok.push({
								value: "keyword",
								data: hit
							})
							len+=hit.length
							continue
						}
					}
					if(hit=="success") {
						debugger
					}
					state.tok.push({
						value: js_ident,
						data: hit
					})
					len+=hit.length
					continue
					break
			}
		}
		return len
	}
	toString() {
		return state.tok
	}
}
if(typeof exports=="undefined") {
	parser=new parsejs()
	parser.parse(code,0,parser.state)
} else {
	exports.parsejs=parsejs
}
