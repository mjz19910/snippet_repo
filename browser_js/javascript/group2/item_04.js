/** @param {typeof import("./item_04")} exports */
function main(exports) {
	//spell:words vtable
	class RustBasicSymbolGenerator {
		next_symbol_id=0;
		generated_symbol_map=new Map;
		/** @type {symbol|null} */
		last_sym_key=null;
		generate() {
			this.last_sym_key=Symbol();
			this.set(this.last_sym_key,this.next_symbol_id++);
			return this.last_sym_key;
		}
		/** @param {symbol} sym_key @param {number} sym_id
		 */
		set(sym_key,sym_id) {
			this.generated_symbol_map.set(sym_key,sym_id);
		}
		/** @param {any} sym_key
		 */
		get(sym_key) {
			return this.generated_symbol_map.get(sym_key);
		}
		/** @param {any} sym_key
		 */
		has(sym_key) {
			return this.generated_symbol_map.has(sym_key);
		}
		/** @param {any} sym_key_a @param {any} sym_key_b
		 */
		distance(sym_key_a,sym_key_b) {
			if(this.has(sym_key_a)&&this.has(sym_key_b))
				return this.get(sym_key_b)-this.get(sym_key_a);
			throw Error('distance calculation requires symbols generated by this generator');
		}
	}
	exports.RustBasicSymbolGenerator=RustBasicSymbolGenerator;
	class RustBasicExecutor {
		/** @arg {RustBasicSymbolGenerator} key_generator */
		constructor(key_generator) {
			this.key_generator=key_generator;
			this.my_key=key_generator.generate();
		}
		/** @arg {{delay: number}} arg0 */
		poll_fn=({delay}) => {
			return {delay};
		};
		/** @type {any[]}
		 */
		value_vec=[];
		/** @type {any[]}
		 */
		key_vec=[];
		/** @type {(number | undefined)[]}
		 */
		data_start_vec=[];
		/** @type {(number | undefined)[]}
		 */
		data_end_vec=[];
		/** @type {any[]}
		 */
		data_store_vec=[];
		/** @type {(()=>void)|null} */
		lastValue=null;
		get v() {
			return this.lastValue;
		}
		set v(value) {
			this.lastValue=value;
			this.add_function(this.lastKey,this.lastValue,[]);
		}
		/** @type {string} */
		lastKey="";
		get k() {
			return this.lastKey;
		}
		set k(key) {
			this.lastKey=key;
		}
		/** @param {string|symbol} key @param {any} value @param {string | any[]} data_vec
		 */
		add_function(key,value,data_vec) {
			if(key==='') {
				key=this.key_generator.generate();
			}
			this.key_vec.push(key);
			this.value_vec.push(value);
			let data_store_vec=this.data_store_vec;
			this.data_start_vec.push(data_store_vec.length);
			for(let i=0;i<data_vec.length;i++) {
				data_store_vec.push(data_vec[i]);
			}
			this.data_end_vec.push(data_store_vec.length);
		}
		/** @param {any} key
		 */
		key_index(key) {
			return this.key_generator.distance(this.my_key,key)-1;
		}
		/** @param {string} inject_data @param {number[]} data_vec @param {any} key
		 */
		append_auto_info(inject_data,data_vec,key) {
			let inject_data_vec=[];
			if(inject_data.startsWith('req_')) {
				if(inject_data[4]==='$'&&inject_data.at(-1)==='$') {
					let value_name_vec=inject_data.slice(5,-1).split('$');
					for(let x of value_name_vec) {
						inject_data_vec.push(x);
					}
				}
			}
			for(let cur of inject_data_vec) {
				switch(cur) {
					case 'sym_distance':
						let sym_distance=this.key_index(key);
						data_vec.unshift(sym_distance);
						break;
					default:
						throw Error('Unhandled argument injection:"'+cur+'"');
				}
			}
		}
		/** @param {string} key @param {{(...arg0: any[]):any;name:string}} value @param {any[]} data_vec
		 */
		execute_function(key,value,data_vec) {
			value.name&&this.append_auto_info(value.name,data_vec,key);
			return value(...data_vec);
		}
		execute(id=0) {
			let key=this.key_vec[id];
			let value=this.value_vec[id];
			let data_vec=this.data_store_vec.slice(this.data_start_vec[id],this.data_end_vec[id]);
			try {
				let ret=this.execute_function(key,value,data_vec);
				return ret;
			} finally {}
		}
	}
	let key_generator=new RustBasicSymbolGenerator;
	var cur=new RustBasicExecutor(key_generator);
	cur.k='';
	/** @arg {{delay: number}} arg0 */
	cur.poll_fn=function({delay}) {
		act: {
			return {
				delay
			};
		}
		return {
			delay
		};
	};
	cur.v=function req_$sym_distance$(/** @type {any} */ sym_distance) {
		sym_distance;
		class RustCrateHandler extends Map {
		}
		class RustScope {
			crate=new RustCrateHandler;
		}
		let rust_scope=new RustScope;
		class RustCrate {
			/** @type {{ definition_vec: any[]; }[]}
			 */
			define_vec=[];
			/** @param {any[]} arg_vec
			 */
			type(...arg_vec) {
				arg_vec;
				return null;
			}
			/** @arg {[a:string,b:string,c:string,d:RustFunctionDefinition,e:(ptr: { value: any; }) => any]} arg_vec */
			define(...arg_vec) {
				this.define_vec.push({
					definition_vec: arg_vec
				});
			}
			/** @arg {[a:string,b:string,c:string,d:(ptr: { value: any; }) => any]} arg_vec */
			define_4(...arg_vec) {
				this.define_vec.push({
					definition_vec: arg_vec
				});
			}
		}
		let rust_tmp=new RustCrate;
		class RustFunctionDefinition {
			/** @param {string} name @param {{type_param: RustTypeParameter[]; arg_def: RustFunctionArgument[]; return_type: string}} info
			 */
			constructor(name,info) {
				this.name=name;
				this.info=info;
			}
		}
		class RustTypeParameter {
			/** @param {string} var_name @param {string} var_type
			 */
			constructor(var_name,var_type) {
				this.name=var_name;
				this.type=var_type;
			}
		}
		class RustFunctionArgument {
			/** @param {string} name @param {RustType} type
			 */
			constructor(name,type) {
				this.name=name;
				this.type=type;
			}
		}
		class RustType {
			/** @param {string} qual @param {string | null} type
			 */
			constructor(qual,type) {
				this.qual=qual;
				this.type=type;
			}
		}
		/** @template T */
		class RustTypeValue {
			/**  @param {RustType} type_info @param {T} value
			 */
			constructor(type_info,value) {
				this.type_info=type_info;
				this.value=value;
			}
			unwrap() {
				return this.value;
			}
		}
		rust_scope.crate.set('mem',rust_tmp);
		let take_def=new RustFunctionDefinition('take',{
			type_param: [new RustTypeParameter('T','Default')],
			arg_def: [new RustFunctionArgument('dest',new RustType('&mut','T'))],
			return_type: 'T'
		});
		rust_tmp.define('take','Option<T>','any T',take_def,function read(/** @type {{ value: any; }} */ ptr) {
			// unsafe
			{
				return ptr.value;
			}
		});
		rust_tmp=new RustCrate;
		rust_scope.crate.set('ptr',rust_tmp);
		class RustUnit {
			toString() {
				return '()';
			}
		}
		class RustOption {
			/** @param {any} value
			 */
			constructor(value) {
				this.value=value;
			}
			is_none() {
				if(0) {
					let tx=rust_vm.start_syntax_transact();
					let mat_expr=tx.start_match();
					mat_expr.head_transact().set_expr('*self');
					let b_tx=mat_expr.body_transact().start_block('{}');
					b_tx.set_sep(',');
					b_tx.add_item('Some(_) => true');
					b_tx.add_item('_ => false');
					tx.close();
					let syntax=tx.build();
					let js=syntax.into('js');
					let fn=js.build_function();
					return Reflect.apply(fn,this,[]);
				}
				return this.value===null;
			}
			is_some() {
				return this.value!==null;
			}
			/** @param {{ unwrap: () => any; }} ref
			 */
			contains(ref) {
				let other_value=ref.unwrap();
				return this.value===other_value;
			}
			unwrap() {
				if(this.value===null) {
					throw Error('rust panic');
				}
				return this.value;
			}
			take() {
				let value=this.value;
				this.value=null;
				return new RustOption(value);
			}
		}
		rust_tmp.define_4('unsafe read()','Option<T>','any T',function read(/** @type {{ value: any; }} */ ptr) {
			let ret;
			unsafe: {
				ret=ptr.value;
				break unsafe;
			}
			return ret;
		});
		rust_tmp.define_4('unsafe write()','Option<T>','any T',function read(/** @type {{ value: any; }} */ trg_ptr,/** @type {any} */ value) {
			unsafe: {
				trg_ptr.value=value;
				break unsafe;
			}
		});
		class AutomationFuture {
			constructor() {
				window.__cint=-1;
				this.canceled=false;
				this.state={
					count: 0
				};
			}
			/** @param {{ canceled: any; }} self @param {{ waker: { clone: () => any; }; }} cx
			 */
			poll(self,cx) {
				let delay=50;
				let poll_scope=cur.poll_fn({
					delay
				});
				({delay}=poll_scope);
				let __cint=window.__cint;
				if(__cint&&__cint>-1) {
					clearTimeout(__cint);
				}
				if(self.canceled) {
					return ['Poll::Ready',new RustUnit];
				}
				if(window.__active_task) {
					let at=window.__active_task;
					if(!at.future.contains(new RustTypeValue(new RustType('&',null),self))) {
						at.cancel();
					}
				}
				let waker=cx.waker.clone();
				let current_task={
					future: new RustOption(self),
					waker: new RustOption(waker),
					timeout_id: -1,
					cancel() {
						let f=this.future;
						if(f.is_some()) {
							f.take().unwrap().canceled=true;
						}
					}
				};
				window.__active_task=current_task;
				current_task.timeout_id=setTimeout(function() {
					window.__cint=-1;
					let task_waker=current_task.waker.take().unwrap();
					task_waker.wake();
					task_waker.drop();
				},delay);
				return ['Poll::Pending'];
			}
		}
		class task_Waker {
			/** @param {{ future?: any; executor: any; from_waker?: any; }} data
			 */
			constructor(data) {
				if(!data.from_waker) {
					data.executor.waker_new();
				}
				this.data=data;
				this.ref_count=1;
			}
			clone() {
				this.ref_count++;
				return new task_Waker({
					...this.data,
					from_waker: this
				});
			}
			drop() {
				this.ref_count--;
				if(this.ref_count===0) {
					if(this.data.from_waker) {
						this.data.from_waker.drop();
					} else {
						this.data.executor.waker_drop();
					}
				}
			}
			wake() {
				let a=this.data;
				let b=a.executor;
				let c=a.future;
				b.task_queue.push_back(c);
				b.notifier.notify_one();
			}
		}
		class task_Context {
			/** @arg {task_Waker} waker */
			constructor(waker) {
				this.waker=waker;
			}
		}
		let cur_executer=null;
		/** @template T */
		class ArrayDequeue {
			/** @param {number} cap
			 */
			constructor(cap) {
				this.cap=cap;
				/** @type {(T|null)[]} */
				this.inner=Array(cap);
				this.len=0;
				this.front_index=0;
				this.back_index=0;
			}
			/** @param {any} value
			 */
			push_back(value) {
				this.len++;
				if(this.len>this.cap) {
					this.inner.length*=2;
					this.cap*=2;
				}
				this.inner[this.back_index]=value;
				this.back_index++;
				this.back_index%=this.cap;
			}
			pop_front() {
				if(this.len<=0) {
					return null;
				}
				let value=this.inner[this.front_index];
				this.inner[this.front_index]=null;
				this.front_index++;
				this.front_index%=this.cap;
				this.len--;
				return value;
			}
			is_empty() {
				return !this.len;
			}
		}
		class Waker {
			/** @arg {WakerVtable} vtable @param {{ notifier: any; }} data
			 */
			constructor(vtable,data) {
				if(!vtable.wake) {
					throw Error('no waker');
				}
				this.data=data;
				this.vtable=vtable;
			}
			wake() {
				this.vtable.wake(this.data);
			}
		}
		class WakerVtable {
			/** @param {any} wake_callback
			 */
			constructor(wake_callback) {
				this.wake_callback=wake_callback;
			}
			/** @param {{ notifier: { wake_count: number; }; }} data
			 */
			wake(data) {
				data.notifier.wake_count++;
				this.wake_callback();
			}
		}
		class AsyncNotifier {
			/** @arg {AsyncNotifier} notifier @param {(value: any) => void} accept @param {()=>void} reject
			 */
			static promise_execute(notifier,accept,reject) {
				reject;
				notifier.waker=new Waker(new WakerVtable(accept),{
					notifier
				});
			}
			constructor() {
				/** @type {{ wake: () => void; } | null}
				 */
				this.waker=null;
				this.wake_count=0;
				/** @type {{}|null}
				 */
				this.inner=null;
				this.notifier=null;
			}
			notified() {
				this.inner??=new Promise(AsyncNotifier.promise_execute.bind(AsyncNotifier,this));
				return this.inner;
			}
			reset() {
				this.inner=null;
				this.waker=null;
			}
			async wait() {
				if(!this.wake_count) {
					await this.notified();
					this.reset();
				}
				if(this.wake_count) {
					this.wake_count--;
				}
			}
			notify_one() {
				if(this.waker) {
					this.waker.wake();
				}
			}
		}
		class TimeoutExecutor {
			/** @type {any}
			 */
			active=[];
			/** @type {ArrayDequeue<AutomationFuture>} */
			task_queue=new ArrayDequeue(4);
			notifier=new AsyncNotifier;
			waker_count=0;
			waker_new() {
				this.waker_count++;
			}
			waker_drop() {
				this.waker_count--;
				if(this.waker_count===0) {
					this.notifier.notify_one();
				}
			}
			/** @arg {AutomationFuture} fut */
			spawn(fut) {
				this.task_queue.push_back(fut);
			}
			/** @arg {AutomationFuture} fut */
			run_one(fut) {
				let waker=new task_Waker({
					future: fut,
					executor: this
				});
				let res=fut.poll(fut,new task_Context(waker));
				waker.drop();
				if(res[0]==='Poll::Ready') {
					if(res[1] instanceof RustUnit)
						res[1]=res[1].toString();
					console.log('wake_res_ready',res[1]);
				}
			}
			async*run() {
				if(this.task_queue.is_empty()) {
					if(this.waker_count===0) {
						return;
					}
					await this.notifier.wait();
					return;
				}
				for(;;) {
					if(!this.task_queue.is_empty()) {
						let value=this.task_queue.pop_front();
						if(!value) {
							yield value;
						} else {
							this.run_one(value);
							yield value;
						}
					}
					if(this.task_queue.is_empty()) {
						await this.notifier.wait();
					}
					if(this.waker_count===0&&this.task_queue.is_empty()) {
						return;
					}
				}
			}
			async async_block_on_all() {
				let runner=this.run();
				for(;;) {
					let cur=runner.next();
					let res=await cur;
					if(res.done) {
						console.log('done');
						break;
					}
				}
			}
		}
		exports.TimeoutExecutor=TimeoutExecutor;
		if(window.__cur_task) {}
		cur_executer=new TimeoutExecutor;
		cur_executer.spawn(new AutomationFuture);
		cur_executer.async_block_on_all();
		window.__cur_task=cur_executer;
	};
	return cur.execute();
}
/** @template U @template {U} T @arg {U} e @returns {T} */
function cast_as(e) {
	/** @type {any} */
	let x=e;
	return x;
}
if(typeof exports==='object') {
	exports.main=main;
	main(exports);
} else {
	main(cast_as({
		main,
	}));
}
