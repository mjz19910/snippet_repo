/*
Copyright 2021-2021 @mjz19910

Header definition:
class RustBasicSymbolGenerator{
	next_symbol_id = 0
	generated_symbol_map = new Map
	last_sym_key = null
	generate(){}
	set(sym_key,sym_id){}
	has(sym_key){}
	get(sym_key){}
	distance(sym_key_a,sym_key_b){}
}
class RustBasicExecutor{}
function main(){
	let key_generator = new RustBasicSymbolGenerator
	var cur = new RustBasicExecutor(key_generator)
	cur.k = ''
	cur.v = function req_$sym_distance$(sym_distance) {}
}
*/
class RustBasicSymbolGenerator {
	next_symbol_id=0
	generated_symbol_map=new Map
	/** @type {symbol|null} */
	last_sym_key=null
	generate() {
		this.last_sym_key=Symbol()
		this.set(this.last_sym_key,this.next_symbol_id++)
		return this.last_sym_key
	}
	/**
	 * @param {symbol} sym_key
	 * @param {number} sym_id
	 */
	set(sym_key,sym_id) {
		this.generated_symbol_map.set(sym_key,sym_id)
	}
	/**
	 * @param {any} sym_key
	 */
	get(sym_key) {
		return this.generated_symbol_map.get(sym_key)
	}
	/**
	 * @param {any} sym_key
	 */
	has(sym_key) {
		return this.generated_symbol_map.has(sym_key)
	}
	/**
	 * @param {any} sym_key_a
	 * @param {any} sym_key_b
	 */
	distance(sym_key_a,sym_key_b) {
		if(this.has(sym_key_a)&&this.has(sym_key_b))
			return this.get(sym_key_b)-this.get(sym_key_a)
		throw Error('distance calculation requires symbols generated by this generator')
	}
}
class RustBasicExecutor {
	/**
	 * @type {any[]}
	 */
	value_vec=[]
	/**
	 * @type {any[]}
	 */
	key_vec=[]
	/**
	 * @type {(number | undefined)[]}
	 */
	data_start_vec=[]
	/**
	 * @type {(number | undefined)[]}
	 */
	data_end_vec=[]
	/**
	 * @type {any[]}
	 */
	data_store_vec=[]
	/**
	 * @param {RustBasicSymbolGenerator} key_generator
	 */
	constructor(key_generator) {
		this.key_generator=key_generator
		this.my_key=key_generator.generate()
	}
	/**
	 * @type {any}
	 */
	lastValue;
	get v() {
		return this.lastValue
	}
	set v(value) {
		this.lastValue=value
		this.add_function(this.lastKey,this.lastValue,[])
	}
	/**
	 * @type {string}
	 */
	lastKey="";
	get k() {
		return this.lastKey
	}
	set k(key) {
		this.lastKey=key
	}
	/**
	 * @param {string|symbol} key
	 * @param {any} value
	 * @param {string | any[]} data_vec
	 */
	add_function(key,value,data_vec) {
		if(key==='') {
			key=this.key_generator.generate()
		}
		this.key_vec.push(key)
		this.value_vec.push(value)
		let data_store_vec=this.data_store_vec
		this.data_start_vec.push(data_store_vec.length)
		for(let i=0;i<data_vec.length;i++) {
			data_store_vec.push(data_vec[i])
		}
		this.data_end_vec.push(data_store_vec.length)
	}
	/**
	 * @param {any} key
	 */
	key_index(key) {
		return this.key_generator.distance(this.my_key,key)-1
	}
	/**
	 * @param {string} inject_data
	 * @param {number[]} data_vec
	 * @param {any} key
	 */
	append_auto_info(inject_data,data_vec,key) {
		let inject_data_vec=[]
		if(inject_data.startsWith('req_')) {
			if(inject_data[4]==='$'&&inject_data.at(-1)==='$') {
				let value_name_vec=inject_data.slice(5,-1).split('$')
				for(let x of value_name_vec) {
					inject_data_vec.push(x)
				}
			}
		}
		for(let cur of inject_data_vec) {
			switch(cur) {
				case 'sym_distance':
					let sym_distance=this.key_index(key)
					data_vec.unshift(sym_distance)
					break
				default:
					throw Error('Unhandled argument injection:"'+cur+'"')
			}
		}
	}
	/**
	 * @param {string} key
	 * @param {{(...arg0:any[]):any;name:string}} value
	 * @param {any[]} data_vec
	 */
	execute_function(key,value,data_vec) {
		value.name&&this.append_auto_info(value.name,data_vec,key)
		return value(...data_vec)
	}
	execute(id=0) {
		let key=this.key_vec[id]
		let value=this.value_vec[id]
		let data_vec=this.data_store_vec.slice(this.data_start_vec[id],this.data_end_vec[id])
		try {
			let ret=this.execute_function(key,value,data_vec)
			return ret
		} finally {}
	}
}
function main() {
	{
		let key_generator=new RustBasicSymbolGenerator
		var cur=new RustBasicExecutor(key_generator)
	}
	cur.k=''
	cur.v=function req_$sym_distance$(/** @type {any} */ sym_distance) {
		console.log('sym_distance',sym_distance)
	}
	return cur.execute()
}
main()
