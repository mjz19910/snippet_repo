let token="Eg0SCzh6aWxFZ19mZVpBGAYy9wcKzAdnZXRfcmFua2VkX3N0cmVhbXMtLUNvUUZDSUFFRlJlMzBUZ2EtUVFLOHdRSTJGOFFnQVFZQnlMb0JBTTJJbEpkeGZDQ3dTVE85V0h4bk92LXdtMHJKLVhRN0g3b0pRMk0tS0JuN1BPMWVPZnMxamUyWERqNTc4cVhka2VkMXVPeW9BMHZxNUwwcF9uVGowRzQyNWVncXhtM1k1SjdTWUpISmJuMzIyVWx6WXRHZWN1YnBoc2ZIOEl3dXB2SmV6M0o2blZ0LXJ4MHB1NDZHYzNETDRVU2ZlVkRvRmFHRW92UmJGc3l5d01OdkpzVjBlSkNIcVVVa1NrNG5sWlI2bE45akNtSkZPU1JTb3hLVXRhSFJOcjJKS1hkVldaOXpjcXBHNm5jdEY5VE83d21uOW9ZcHBmcGotNGtQazlEbjBZeEo1RlpnMXpxcFhBYnVQV0pzZmhRNDlKTTRpX3JzTHdqYVNrbGV2d3lxWG1JZnRub2NpbVhvWmRKaTloazQ1SkpoMFhDaHRRMVAwUUt1Wi05dXhSYWhTNHFVMWRwLWVPX2hZZWZEUHViV1lnUElhZUpmMXkteU9JaU1XUjNLaE9Xd2RfbFVYcXlfNVBlRUNXZms4Uzh0TnRmbTZqY2NmRjktU3BiTU5NWlAwd3hZVG5xdVkxbEdqTFNQVW5yd3lSdmtTU2ZCN1E2VDlacWxlX3hPek1aajB1STVFWmJiaEh2VXg3T1VTLUhSOGM5eDlIa1pmT2MtdzFibDI5MVRibVZjV1g1ZUE2MllJczhjTW4yUV9vaWVKTWxGMjJQa1loWXpxWjVzaTlPQjktU0J0ZDlXVU1ZZnFsVl9vQ3JDOHVEdWhaUnRXbGZwY21rUnNkQkZwM3gtSmFvTmJlTXRMUG1mTEFvOVdoNmZEbHMyOHYzcmo2RUJRWEowSU5FRFAxWHRUcDRKMllsRFNfREFYTTVuWFQyNVhtcEpZVHBsRXJmcTlRRmQ1TlJ4SW5UdnNUUGxDSmVHdE9nd2xMNWtHZ01TOE5IajF6eGR1RHBoX2lhUTVMelAzMUhuRnRJTTN1M3JZbGJYYUppX0JKRVNJNXN2MlhMYm93aXZJMFNSVjdITHBjWmhYVzRVakNaNlVMLWJjUjBiQ3FxSGtST3FFZThfVUs0WVlsTjQyejRjQUVRakFFU0J3aWZJQkFBR0FBU0JRaUpJQmdBRWdnSWhTQVFqQUVZQVJJRkNJZ2dHQUFTQndpRUlCQXdHQUVTQlFpSElCZ0FFZ2NJbHlBUWNoZ0JFZ1VJaGlBWUFCZ0IiESILOHppbEVnX2ZlWkEwAHgBKIwBQhBjb21tZW50cy1zZWN0aW9u";
token=`
Eg0SCzh6aWxFZ19mZVpBGAYyrgoKgwpnZXRfcmFua2VkX3N0cmVhbXMtLUN1d0dDSUFFRlJlMzBUZ2E0UVlLMndZSTJGOFFnQVFZQnlMUUJnTTJFU0xWVWNSd0NJSXVKc1ZpcWt0blNXaFZzdk4tWTdhZ1dveVhvaHlVN1Y1YjhKSVNNNkpmdEM1SUxJVGRoLXJrSFVtTFd4LU1MUmRPaGhyUVFpQVpsQ190ampxdFI2d0xHdVZEYVNxb0pOMTd4RW0tbEc4cUpFamRaSjBrNkdyR0ZvNUpwSFF1UlFTUFNuTHZCNU5EcUtRVXlVU1NVWlMzZ3JKcG9sR1JlcDJ5eTZEZDNVekdqRkkzbDlWcnFFM0R1Vk5uaWlTdWs5RThsS3B6b1VULVNHWTRNbEV3cHk0bEZxUFpObEUweTRQSXdMdFpFWlRpUWk1TjJDU0lURXhPZEZMQ0pFcEpwM3FJNmtTY1JBcnlTTVUxS29rRW1jaXVnVWhaS1pZa3BVMVZ4R1RXVzhxcVFxR2hrY3BOTy0tSmltTGh1VEN5VDIwTVU1OHkwdW5CblFUTmFKa3l1WXVqeXlaQ1RpS3pFYkhZWE1OU1dCSmxia2tYWVRSQ2wwNU5MSGhxSm5GNXdCS0dTQ1R2U0ZwS29lUW00VXNwYWg0Uy1haGlYQWpYS0xGY3FGbmhNZ2tXTWExV21qUkJpcVNVRzB0QXlVUVVUYTNkSlpJYU1Vcy1vUmN6bDBLcmtBNUVLbE5YY1d3MjJfYW5FdHluLTJiWTM4eEN0RHFFbkNiR0gwTDVJaHpNUlZ5RE5YY3FFeG9Qamc4bUY1SWdEWlBKLVZLNW9kNFFSY3M1aVd1T1NoSnV3aWZjeUpxbzNFMmlPaTlZdjZDb0JBMW1SckxpS1NOS3NaTFEtQ2g0YnB1UWN4d3dJV25GUWtFYTFXR1NveHNiU2VCaTA0RG1QQWNLMXNpeHltTmpfczVJSXNZNExDR2dpQnRoZDI4UjVUd0ZsWUVueHFDWFZta3M2b2hiVmg5TjhxYlpjNlJPTlNDMkxrbm9MSEZOdVJXdm9iS2NwdDRSVFl4WnNFVWV1R1Q3SVcyTXhDZ21NcU1zSElwS3Fuc3hJbUtKSEUwUTAwRDJ4V2x4TjIxU05ManV5eHJDTU45cWxWOGNWMUpoZVZEWElxbzI3WU9Sb0V0SWFuUjBZMWxVUWlVcW1zdXBDTFZnYmhJRktSZldiTzFnVGFUU3FtYmtMYjFRc0xaTkVtV01wNUpVSFdOWWlBU0poTWlETUdQb0wxMVFqUndINTBMTVNvTGhKZkVCYzdrSXA2UmV5WmR0ODZSQlFnZ2NUNnFGcXN4VktqZTBTY1FrczRpVFdiS0pGa28zWXdxVUl0WkloWkFTcTdCVWpwUVNGZVd3TkZ5N094a0h4YkMxeWdPOW1yZzZjNUtFT1RCS21MbmRoRkloRG5mRW1VcElNNk1GSmR1YXVHRlpvbUo4UlRVUmtyS3gzY2RzMlVsWVRJUnBHU1dLYUN0eDdJS2h5b3JDT3RDTmdzbWl4QnU1ekJNaFpVeS1vQVVWVlE4aUYwSDFHckFOTFdWTWhCdVdSRTBwVFVTR0Q0VVRFTndCRWdjSWhDQVFQUmdCRWdVSWlDQVlBQklJQ0lVZ0VOd0JHQUVTQlFpSklCZ0FFZ2NJbnlBUUFCZ0FFZ1VJaGlBWUFCSUlDSmNnRUtJQkdBRVNCUWlISUJnQUdBRSIRIgs4emlsRWdfZmVaQTAAeAEo3AFCEGNvbW1lbnRzLXNlY3Rpb24%3D
--
Eg0SCzh6aWxFZ19mZVpBGAYyJSIRIgs4emlsRWdfZmVaQTAAeAJCEGNvbW1lbnRzLXNlY3Rpb24%3D
--
Eg0SCzh6aWxFZ19mZVpBGAYypAcK-gZnZXRfcmFua2VkX3N0cmVhbXMtLUNzY0VDSUFFRlJlMzBUZ2F2QVFLdHdRSTJGOFFnQVFZQnlLc0JBTTJJdGRWREM4WVRPSmNIeGJQdF8yOWJlV2t2Tm45aHpRd1B1b1otMl9EbXQzNnhYWk9fcnZ5cGQxUnAxLVdCVzE0V1pXa1BfM0RINFg3anljemJzY2s5NUlFajByeS1YWlpTZThhNVMxdm1tNzh4ekNNN21ieVhrLXlmbW42dlBUZGRUS2FoMThLSmZyS2gwRHRzaFk3MkpZNER6VHZab1dMQzIxU2lzZ1VIRS1yS1BXcFBzWlJaSnRMakVwU2ZrMmtiVTlTMmwzbEg3Snlta2pscHYyNl9qWDUxTVl3dlV4X2RDZTVUa09mUmpFbmtUbGY2cVczdWZWajhhSEdvMG44NTJINVJscEsyZUtYU2MzRGR0bm9jaW1YNFRCcHdXbGZNdW13U05odzBmd1FhZTVuN3k2RlZybnAxbFZhX3ZqZl9sZnNiMlloUG9TY3BqOHRueFlYaVNIN05PSEYzLVZSZXJMXy13MVI4cm5GdkxUX1F4Ty00M0pldnNyVzdJWWZwcGpMVWM5dExOT1o3NjMxSjNtTEpQazg0REJQMW1xVjdfRTdzX0o0aWVSR1c5N3hQdVhoSFBWeWVIVGNjeHhOWHJZMTl4dTJMdF9xZWhpX3NIdzh0NlZISG5pM0g5SVh3WnNzdVF3X0VCSEwyVFJQOXNYcDRGdXFyaF9XRVA1dmY4SFZoZVZCWTJHMWFaLWJUUG95eUtJekh0OWlhMjRaYVdjOUhxeldvLW54NWJCdEw5LTctbkJCUVRMMFVESDBYOVhxNEoyWWxmVExjSmpLNmFTekw4OUxMU0ZNcDYzdlZlcUNPNDdreEdsZjRtZEtFUy1OYVZCaHFmeEVZMWdhUHZvZGJ3ZWVmb2l2T1NRNV85TjN4TG1GTkxOMzI1cTQxU1hxOENXSTBKWHR0MnpaTFlud05rcDlIcnRjWmhUVzRVb0JaN3FRZnhzeEhSdHJEQ0tuMV9zdkZ5eXg2U3MtWEFBUWVCSUhDSVVnRUhnWUFSSUhDSjhnRUFBWUFCSUZDSWtnR0FBU0J3aUVJQkF0R0FFU0JRaUlJQmdBRWdVSWh5QVlBQklGQ0lZZ0dBQVNCd2lYSUJCakdBRVlBUSIRIgs4emlsRWdfZmVaQTAAeAEoeEIQY29tbWVudHMtc2VjdGlvbg%3D%3D
`.split("--").at(-1)?.trim()??"";
const text=atob(decodeURIComponent(token).replaceAll("_","/").replaceAll("-","+"));
export const binary=new Uint8Array([...text].map(e => e.charCodeAt(0)));
const string_decoder=new TextDecoder('utf-8');
/** @param {Uint8Array} binary @returns {[number,string]} */
export function decode_str_tlv(binary) {
	let [type,length_]=binary;
	let rest=binary.subarray(2);
	let data=rest.subarray(0,length_);
	let str=string_decoder.decode(data);
	return [type,str];
}
/** @param {Uint8Array} binary @returns {[number,Uint8Array]} */
export function decode_tlv(binary) {
	let [type,length_]=binary;
	let rest=binary.subarray(2);
	let data=rest.subarray(0,length_);
	return [type,data];
}
/**
 * @param {Uint8Array} binary
 * @param {number} idx
 * @returns {[number,number]}
 */
export function dec_uint32(binary,idx) {
	let ret,len=0;
	x: {
		if(binary[idx]>128) {
			console.log('varint bigger',binary[idx],binary[idx+1]);
			ret=(binary[idx]&0x7f);
			len+=2;
			break x;
		}
		ret=binary[idx];
		len++;
	}
	return [ret,len];
}
/**
 * @param {Uint8Array} binary
 */
export function do_token_decode(binary) {
	/* istanbul ignore next */
	/**
	 * @param {Reader} reader
	 * @param {number} [writeLength]
	 */
	function indexOutOfRange(reader,writeLength) {
		return RangeError("index out of range: "+reader.pos+" + "+(writeLength||1)+" > "+reader.len);
	}
	/**
	 * Constructs a new reader instance using the specified buffer.
	 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 * @param {Uint8Array} buffer Buffer to read from
	 */
	function Reader(buffer) {
		/** @type {Uint8Array} */
		this.buf=buffer;
		/** @type {number} */
		this.pos=0;
		/** @type {number} */
		this.len=buffer.length;
	}
	/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
	Reader.prototype.uint32=(function read_uint32_setup() {
		var value=4294967295;
		/** @type {(this: Reader)=>number} */
		return function read_uint32() {
			value=(this.buf[this.pos]&127)>>>0; if(this.buf[this.pos++]<128) return value;
			value=(value|(this.buf[this.pos]&127)<<7)>>>0; if(this.buf[this.pos++]<128) return value;
			value=(value|(this.buf[this.pos]&127)<<14)>>>0; if(this.buf[this.pos++]<128) return value;
			value=(value|(this.buf[this.pos]&127)<<21)>>>0; if(this.buf[this.pos++]<128) return value;
			value=(value|(this.buf[this.pos]&15)<<28)>>>0; if(this.buf[this.pos++]<128) return value;

			/* istanbul ignore if */
			if((this.pos+=5)>this.len) {
				this.pos=this.len;
				throw indexOutOfRange(this,10);
			}
			return value;
		};
	})();
	Reader.prototype.bytes=function read_bytes() {
		var length=this.uint32(),
			start=this.pos,
			end=this.pos+length;

		/* istanbul ignore if */
		if(end>this.len)
			throw indexOutOfRange(this,length);

		this.pos+=length;
		if(Array.isArray(this.buf)) // plain array
			return this.buf.slice(start,end);
		return start===end? new Uint8Array(0):this.buf.slice(start,end);
	};
	/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
	Reader.prototype.skip=function skip(length) {
		if(typeof length==="number") {
			/* istanbul ignore if */
			if(this.pos+length>this.len)
				throw indexOutOfRange(this,length);
			this.pos+=length;
		} else {
			do {
				/* istanbul ignore if */
				if(this.pos>=this.len)
					throw indexOutOfRange(this);
			} while(this.buf[this.pos++]&128);
		}
		return this;
	};
	let reader=new Reader(binary);
	/** @type {[[number],Uint8Array][]} */
	let parts=[];
	x: for(let i=0;;) {
		reader.bytes();
		let xx=reader.uint32();
		console.log('pp',xx);
		switch(xx) {
			default: if(binary[i]>128) {
				console.log('varint bigger',binary[i],binary[i+1]);
			};
				let wireType=xx>>>3;
				console.log('wt',wireType,xx>>3);
				switch(wireType) {
					case 0:
						let [dec,len]=dec_uint32(binary,i);
						console.log('type0',dec);
						i+=len;
						continue;
					case 1:
						reader.skip(8);
						break;
					case 2:
						let ds=dec_uint32(binary,i);
						i+=ds[1];
						console.log('type2',ds[0]);
						let size=ds[0];
						i+=size;
						break;
					case 3:
						while((wireType=reader.uint32()&7)!==4) {
							reader.skipType(wireType);
						}
						break;
					case 5:
						reader.skip(4);
						break;

					/* istanbul ignore next */
					default:
						throw Error("invalid wire type "+wireType+" at offset "+reader.pos);
				}
				i++;
				// goto skipTypeEx;
				if(binary[i]>128) {
					console.log('varint bigger',binary[i],binary[i+1]);
				}
				console.log("t=0x"+wireType.toString(16),"f=0x"+binary[0].toString(16));
				break x;
		}
	}
	// console.log('decode run',result,[[[rest]]],encodeURIComponent(text.slice(0,rest.byteOffset)),encodeURIComponent(text.slice(rest.byteOffset)));
	for(let i=0;i<parts.length;i++) {
		let part=parts[i];
		switch(part[0][0]) {
			case 0x12: console.log('part_type',0x12,decode_str_tlv(parts[i][1])); continue;
		}
		console.log("part type",parts[i][0][0],parts[i][1]);
	}
}

do_token_decode(binary);