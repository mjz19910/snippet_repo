decodedata = ';(7(){d 1e=0;d C=[\'1M\',\'1K\'];T(d x=0;x<C.1c&&!6.z;++x){6.z=6[C[x]+\'1J\'];6.X=6[C[x]+\'1H\']||6[C[x]+\'1I\']}c(!6.z)6.z=7(1x,p){d L=1C 1X().1U();d Q=a.1O(0,16-(L-1e));d B=6.1W(7(){1x(L+Q)},Q);1e=L+Q;P B};c(!6.X)6.X=7(B){1Q(B)}}());(7(6){"1S 1T";d r,u,k,O;r={1i:7(U){d i,Z;T(i=0;i<U.1c;i+=1){Z=1C 1P();Z.1V=U[i]}},1w:7(){P a.n(a.o()*10).M()+a.n(a.o()*10).M()+a.n(a.o()*10).M()+a.n(a.o()*10).M()},E:7(18){d 1m=18[a.n(a.o()*18.1c)];P 1m}};u={t:[]};k={l:{},y:7(j){m.l=j;m.1p(5);O.y();6.1N("1L",7(){6.1R.22()})},1p:7(1q){d i;T(i=0;i<1q;i+=1){u.t.2g(k.l.1g+k.l.12+\'0\'+i+k.l.V)}r.1i(u.t)},1A:7(1f){d 9=\'\',1d,1o=O.$9.b.1G,1b=1o.1r(/^1t\\(["\']?/,\'\').1r(/["\']?\\)$/,\'\'),1j=1b.1n(1b.1s(\'/\')+1);c(1f===\'o\'){9=r.E(u.t);1d=9.1n(9.1s(\'/\')+1);c(1d===1j){9=r.E(u.t)}}F{9=u.t[1f+1]}P 9}};O={y:7(){d 3=m;G.11.b.14=\'N%\';G.11.b.13=\'N%\';3.$q=G.1k(\'1l\');3.$q.b.1D=\'2f\';3.$q.b.2i=\'#2d\';3.$q.b.14=\'N%\';3.$q.b.13=\'N%\';3.$q.B=k.l.1z;3.$q.2h.1Y(\'w\');G.11.1E(3.$q);3.$9=G.1k(\'1l\');3.$9.B=\'2j-9\';3.$9.b.1D=\'2k\';3.$9.b.2e=\'2b\';3.$9.b.13=k.l.19+\'f\';3.$9.b.14=k.l.Y+\'f\';3.$q.1E(3.$9);m.A();3.1v(3.$9)},A:7(){m.$9.b.1G=\'1t(\'+k.1A(\'o\')+\')\'},1v:7(p){d 3=m,H=p.23,K=p.2c,g=k.l.g,17=6.15-(H/10),1h=6.21-(K/10),h=a.n(a.o()*(17-H)),e=a.n(a.o()*(1h-K)),v=r.E(["S","I"]),s=r.E(["R","J"]);7 W(){c(v==="S"){c(h>(17-H-g)){v="I";3.A()}}F c(v==="I"){c(h<g){v="S";3.A()}}c(s==="J"){c(e>(1h-K-g)){s="R";3.A()}}F c(s==="R"){c(e<g){s="J";3.A()}}c(v==="S"){h=h+g}F c(v==="I"){h=h-g}c(s==="J"){e=e+g}F c(s==="R"){e=e-g}p.b.1Z=\'D(\'+h+\'f,\'+e+\'f, 0)\';p.b.20=\'D(\'+h+\'f,\'+e+\'f, 0)\';p.b.24=\'D(\'+h+\'f,\'+e+\'f, 0)\';p.b.25=\'D(\'+h+\'f,\'+e+\'f, 0)\';p.b.2a=\'D(\'+h+\'f,\'+e+\'f, 0)\';6.z(W)};6.z(W)}};d w=7(j){m.y(j)};w.1B.y=7(j){d 1a=a.n(6.15*0.4)>1y?1y:a.n(6.15*0.4),1F=1a/2;m.l={19:j.19||1a,Y:j.Y||1F,g:j.g||8,1g:j.1g||\'t/\',12:j.12||\'27-\',V:j.V||\'.26\',28:29,1z:r.1w()};m.1u()};w.1B.1u=7(){k.y(m.l)};6.w=w})(6);';
key_array = '|||self|||window|function||logo|Math|style|if|var|yPos|px|speed|xPos||options|thecentralscrutinizer|parameters|this|floor|random|element|container|utils|yDir|logos|model|xDir|bouncingdvdlogo||init|requestAnimationFrame|refreshLogo|id|vendors|translate3d|getRandomString|else|document|elementWidth|left|down|elementHeight|currTime|toString|100|view|return|timeToCall|up|right|for|imageUrlArray|imagesExtension|move|cancelAnimationFrame|logoHeight|img||body|imagesPrefix|width|height|innerWidth||xMax|stringArray|logoWidth|defaultWidth|currentLogoUrl|length|logoFilename|lastTime|selection|imagesFolder|yMax|preloadImages|currentLogoFilename|createElement|div|output|substring|currentLogo|loadLogos|quantity|replace|lastIndexOf|url|create|bounce|generateId|callback|400|uid|getLogo|prototype|new|position|appendChild|defaultHeight|backgroundImage|CancelAnimationFrame|CancelRequestAnimationFrame|RequestAnimationFrame|moz|resize|webkit|addEventListener|max|Image|clearTimeout|location|use|strict|getTime|src|setTimeout|Date|add|transform|OTransform|innerHeight|reload|offsetWidth|msTransform|MozTransform|jpg|dvdlogo|maxSpeed|50|WebkitTransform|cover|offsetHeight|000|backgroundSize|relative|push|classList|backgroundColor|dvdbouncinglogo|absolute'.split('|')
code = `x=function(p,a,c,k,e,d){
        e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};
        if(!''.replace(/^/,String)){
                while(c--){d[e(c)]=k[c]||e(c)}
                k=[function(e){return d[e]}];
                e=function(){return'\\w+'};
                c=1
            };
            while(c--){
                    if(k[c]){
                            p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])
                        }
                    }
        return p
        }(decodedata,62,145,key_array,0,{})`
var rx = 0
var parsejs = class {
    constructor(s) {
        this.state = {
            getargs: 0,
            parsebody: 0,
            parsebracket: 0,
            pt: 0,
            parast: [],
            tok: [],
            idents: []
        }
        let kwo = {
            [Symbol.iterator]: function*() {
                var tmp = Object.getOwnPropertyNames(this)
                for (let i of tmp) {
                    let s = this[i]
                    if (s.indexOf(",") > 0) {
                        var j = s.split(",")
                        for (var k of j) {
                            yield k
                        }
                    } else {
                        yield s
                    }
                }
            },
            a: "async,await",
            c: "case,catch,class,const,continue",
            d: "debugger,default,delete,do",
            e: "else,exports,extends",
            f: "finally,for,function",
            i: "if,import,in,instanceof",
            l: "let",
            n: "new",
            o: "of",
            r: "return",
            s: "static,super,switch",
            t: "this,throw,try,typeof",
            v: "var,void",
            w: "while,with",
            y: "yield",
            z: []
        }
        var ns = this.state.keywords = new Set()
        for (var i of kwo) {
            ns.add(i)
        }
        this.keywordhandlers = new Map
        let mclass = this.constructor
        for (i of Object.getOwnPropertyNames(Reflect.getPrototypeOf(this))) {
            if (i.match(/eat_/)) {
                this.keywordhandlers.set(i.substr(4), this[i].bind(this))
            }
        }
        this.state.primitives = ["null", "undefined", "true", "false", "NaN", "Infinity", "-Infinity", "String"]
        if (s) {
            let sethandler = function(n, fn) {
                if (!this instanceof mclass) {
                    throw RangeError("this not instance of " + mclass)
                }
                if (typeof fn != "function") {
                    throw TypeError("sethandler called but parameter 2 is not a function")
                }
                this.keywordhandlers.set(n, fn.bind(this))
            }
            let gethandler = function(g) {
                if (!this instanceof mclass) {
                    throw RangeError("this not instance of " + mclass)
                }
                this.keywordhandlers.get(g)
            }
            s(this, sethandler, gethandler)
        }
    }
    expectraw(s, ptr, state, expected) {
        var a = s.indexOf(expected, ptr)
        if (a > 0) {
            return a
        }
        throw Error("Unexpected Eof")
    }
    eat_function(s, ptr, state) {
        state.parast.push(state.pt)
        state.pt = 7
        var save = state.tok
        var named = 0
        state.tok = []
        if (s[ptr] != "()"[0])
            while (1) {
                if (s[ptr] == "()"[0]) {
                    break;
                }
                if (s[0].match(/^\s/)) {
                    ptr++
                } else {
                    named = 1;
                    break
                }
            }
        ptr = this.parse(s, ptr, state, 1)
        state.pt = 3
        var parama = state.tok
        if (s[ptr] != "{}"[0] && s.length < ptr) {
            while (1) {
                if (s[ptr] == "{}"[0]) {
                    break
                }
                if (s[ptr].match(/^\s/)) {
                    ptr++
                } else {
                    throw new SyntaxError("Unexpected identifier")
                }
            }
        }
        ptr++
        state.tok = []
        state.getargs = 0
        state.parsebody = 1
        ptr = this.parse(s, ptr, state, 2)
        var fnbody = state.tok
        if (named) {
            save.push({
                value: "Function",
                head: parama.slice(1),
                body: fnbody,
                name: parama[0].data,
                named: true
            })
        } else {
            save.push({
                value: "Function",
                head: parama,
                body: fnbody,
                named: false
            })
        }
        state.tok = save;
        state.parsebody = 0
        if (state.parast.length > 0) {
            state.pt = state.parast.pop()
        }
        return ptr
    }
    eat_try(s, ptr, state) {
        state.parast.push(state.pt)
        state.pt = 8
        var save = state.tok
        state.tok = []
        ptr = this.parse(s, ptr, state, 1)
        var tryblock = state.tok
        var tryobj = {
            value: "Try",
            body: tryblock
        }
        if (s.substr(ptr, 5) == "catch") {
            state.tok = []
            ptr += 5
            state.pt = 12
            ptr = this.eat_catch(s, ptr, state, tryobj)
        }
        if (s.substr(ptr, 7) == "finally") {
            state.tok = []
            ptr += 7
            state.pt = 9
            ptr = this.eat_finally(s, ptr, state, tryobj)
        }
        if (state.parast.length > 0) {
            state.pt = state.parast.pop()
        }
        save.push(tryobj)
        state.tok = save;
        return ptr
    }
    eat_catch(s, ptr, state, tryobj) {
        if (state.pt != 12)
            throw SyntaxError("Unexpected token catch")
        state.parast.push(state.pt)
        state.pt = 6
        var save = state.tok
        state.tok = []
        ptr = this.parse(s, ptr, state, 1)
        tryobj.catch = {
            head: state.tok
        }
        state.tok = []
        state.pt = 14
        ptr = this.parse(s, ptr, state, 1)
        tryobj.catch.body = state.tok
        state.pt = state.parast.pop()
        return ptr
    }
    eat_finally(s, ptr, state, tryobj) {
        if (state.pt != 9)
            throw SyntaxError("Unexpected token finally")
        state.parast.push(state.pt)
        state.pt = 10
        var save = state.tok
        state.tok = []
        ptr = this.parse(s, ptr, state, 1)
        tryobj.finally = {
            body: state.tok
        }
        state.pt = state.parast.pop()
        return ptr
    }
    eat_while(s,ptr,state){
        throw Error("Not Implemented");
    }
    parse(s, ptr, state, d) {
        var len = ptr
        while (len < s.length) {
            var matchchars = (/^[a-zA-Z$_\d]+/)
            var cs = s.slice(len)
            matchchars.lastIndex = len
            var tok = state.tok
            rx++;
            var td = 0
            if (len > s.length - 1) {
                return
            }
            if (s.charAt(len) == "/" && s.charAt(len + 1) == "*") {
                var end = expectraw(s, ptr, state, "*/")

                var comment = s.substring(ptr + 2, end)
                ptr += end + 2
            }
            switch (s.charAt(len)) {
            case "/":
                if (s[len + 1] == "/") {
                    var end = s.indexOf("\n")
                    //expectraw(s,len,"\n")
                    var comment = s.substring(2, end)
                    console.log(comment)
                    debugger ;len = end
                } else {
                    var prev = state.tok[state.tok.length - 1];
                    if ((prev.value == "ident") || (prev.value == "RParan") || prev.value == "Number" || prev.value == "bracket") {
                        state.tok.push({
                            value: "Operator",
                            data: "/"
                        })
                        len += 1
                    } else {
                        var i = 1
                        var c = s[1]
                        var off = 0
                        var notreg = 0
                        var charexpr = 0
                        var flags = ""
                        do {
                            if (c == '[') {
                                charexpr = 1;
                            } else if (c == ']') {
                                charexpr = 0;
                            } else if (c == '\\') {
                                i += 2
                                c = s[len + i]
                                continue
                            } else if (!charexpr && c == '/') {
                                i++
                                break;
                            }
                            c = s[len + (++i)]
                        } while (c);while ("gimuy".indexOf(s[len]) >= 0) {
                            flags += s[len + i];
                            i++
                        }
                        console.log(c)
                        var regex = s.substring(len + 1, len - flags.length)
                        state.tok.push({
                            value: "Regex",
                            data: new RegExp(regex,flags)
                        })
                        len += i
                    }

                }
                break
            case " ":
            case "\t":
                state.tok.push({
                    value: "whitespace"
                })
                len += 1
                break
            case "\n":
            case ";":
                if (state.tok.length == 0) {
                    len += 1
                    break
                }
                if (state.tok[state.tok.length - 1]) {
                    if (state.tok[state.tok.length - 1].value == "Seperator") {
                        state.tok.pop()
                        if (state.tok.length == 0) {
                            break
                        }
                    }
                    if (state.tok[state.tok.length - 1].value != "LBracket") {
                        state.tok.push({
                            value: "Seperator"
                        })
                        len += 1
                    } else {
                        len += 1
                    }
                } else {
                    state.tok.push({
                        value: "Seperator"
                    })
                    len += 1
                }
                break
            case "(":
                if (state.pt == 6 || state.pt == 12) {
                    state.pt = 11
                    len += 1
                    break
                    // no tokens for this when in para mode 6
                }
                if (state.pt == 7) {
                    state.parast.push(state.pt)
                    state.pt = 11
                    len += 1
                    break
                }
                state.tok.push({
                    value: "LParan"
                })
                len += 1
                break
            case "{":
                if (state.pt == 1 || state.pt == 8 || state.pt == 14) {
                    state.parast.push(state.pt)
                    state.pt = 5
                    len += 1
                } else {
                    state.parast.push(state.pt)
                    state.pt = 4
                    // state parse jsonlike
                    state.tok.push({
                        value: "LBracket"
                    })
                    len += 1
                }
                break
            case "}":
                if (state.tok.length > 1 && state.tok[state.tok.length - 1].value == "Seperator") {
                    state.tok.pop()
                }
                if (state.pt == 0) {
                    break
                }
                if (state.pt == 4) {
                    state.tok.push({
                        value: "RBracket"
                    })
                    state.pt = state.parast.pop()
                    break
                }
                if (state.pt == 5 || state.pt == 3) {
                    state.pt = state.parast.pop()
                    return len + 1
                }
                //console.log(state.tok.slice(state.tok.length > 20 ? state.tok.length - 20 : 0, state.tok.length))
                return len + 1
                break
            case ")":
                if (state.pt == 11) {
                    state.pt = state.parast.pop();
                    return len + 1
                }
                if (state.pt == 1) {
                    state.tok.push({
                        value: "RParan"
                    })
                    return len + 1
                }
                state.tok.push({
                    value: "RParan"
                })
                len += 1
                break
            case "!":
                if (s[len + 1] == "=") {
                    if (s[len + 2] == "=") {
                        state.tok.push({
                            value: "Operator",
                            data: "!=="
                        })
                        len += 3
                    } else {
                        state.tok.push({
                            value: "Operator",
                            data: "!="
                        })
                        len += 2
                    }
                } else {
                    state.tok.push({
                        value: "Operator",
                        data: "!"
                    })
                    len += 1
                }
                break
            case ",":
                state.tok.push({
                    value: "Operator",
                    data: ","
                })
                len += 1
                break
            case '"':
                var off = 0
                do {
                    if (s[off] == "\\") {
                        off++
                    }
                    off++
                } while (s[off] != '"')var string = s.substring(1, off)
                state.tok.push({
                    value: "primitive",
                    type: "String",
                    data: string
                })
                len = off + 1
                break
            case "'":
                var match = s.indexOf("'", len + 1)
                if (match) {
                    state.tok.push({
                        value: "primitive",
                        type: "StringSingle",
                        data: s.substring(len + 1, match)
                    })
                    len = match + 1
                } else {
                    throw "Syntax error:unmatched quote"
                }
                break
            case "=":
                if (s[len + 1] == "=") {
                    if (s[len + 2] == "=") {
                        state.tok.push({
                            value: "Operator",
                            data: "==="
                        })
                        len += 3
                    } else {
                        state.tok.push({
                            value: "Operator",
                            data: "=="
                        })
                        len += 2
                    }
                } else {
                    state.tok.push({
                        value: "Asignment"
                    })
                    len += 1
                }
                break
            case "&":
                if (s[1] == "&") {
                    state.tok.push({
                        value: "Operator",
                        data: "&&"
                    })
                    len += 2
                } else {
                    state.tok.push({
                        value: "Operator",
                        data: "&"
                    })
                    len += 1
                }
                break
            case "|":
                if (s[ptr + 1] == "|") {
                    state.tok.push({
                        value: "Operator",
                        data: "||"
                    })
                    len += 2
                } else {
                    state.tok.push({
                        value: "Operator",
                        data: "|"
                    })
                    len += 1
                }
                break
            case "^":
                state.tok.push({
                    value: "Operator",
                    data: "^"
                })
                len += 1
                break
            case ".":
                if (s[1] == "." && s[2] == ".") {
                    state.tok.push({
                        value: "Operator",
                        data: "..."
                    })
                    len += 3
                } else {
                    state.tok.push({
                        value: "Operator",
                        data: "."
                    })
                    len += 1
                }
                break
            case "?":
                state.tok.push({
                    value: "Operator",
                    data: "?",
                    depth: td
                })
                td++
                len += 1
                break
            case ":":
                if (state.pt == 4) {
                    state.tok[state.tok.length - 1].eatnext = true
                    break
                }
                state.tok.push({
                    value: "Operator",
                    data: ":"
                })
                len += 1
                break
            case "-":
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
                var i = 0
                if (s[len] == "-") {
                    if (/\d/.test(s[len])) {
                        i++
                        while (/\d/.test(s[len + i])) {
                            i++
                        }
                    }
                } else {
                    if (/\d/.test(s[len])) {
                        i++
                        while (/\d/.test(s[len + i])) {
                            i++
                        }
                    }
                }
                match = s.substr(len, i)
                if (i > 0) {
                    state.tok.push({
                        value: "Number",
                        data: Number.parseInt(match)
                    })
                    len += match.length
                } else {
                    if (s[ptr + 1] == "-") {
                        state.tok.push({
                            value: "Operator",
                            data: "--"
                        })
                        len += 2
                    } else if (s[ptr + 1] == "=") {
                        state.tok.push({
                            value: "Operator",
                            data: "-="
                        })
                        len += 2
                    } else {
                        state.tok.push({
                            value: "Operator",
                            data: "-"
                        })
                        len += 1
                    }
                }
                break
            case "[":
                if (s[1] == "]") {
                    state.tok.push({
                        value: "bracket",
                        empty: true,
                        body: []
                    })
                    len += 2
                } else {
                    if (state.pt != 0) {
                        state.parast.push(state.pt)
                    }
                    state.pt = 2
                    var save = state.tok
                    state.tok = []
                    state.parsebracket = 1
                    len += 1
                    len = this.parse(s, len, state, 2)
                    // We already ate one bracket, recurse while specifying
                    var bracket = state.tok
                    save.push({
                        value: "bracket",
                        body: bracket
                    })
                    state.tok = save
                    state.parsebracket = 0
                    if (state.parast.length > 0) {
                        state.pt = state.parast.pop()
                    }
                    continue
                }
                break
            case "]":
                if (typeof d == "undefined") {
                    throw "Unbalanced bracket or array notation"
                }
                d--
                if (d == 1) {
                    return len + 1
                }
                break
            case ">":
                if (s[1] == ">") {
                    state.tok.push({
                        value: "Operator",
                        data: ">>"
                    })
                    len += 2
                } else {
                    state.tok.push({
                        value: "Operator",
                        data: ">"
                    })
                    len += 1
                }
                break
            case "<":
                if (s[ptr + 1] == "<") {
                    state.tok.push({
                        value: "Operator",
                        data: "<<"
                    })
                    len += 2
                } else {
                    state.tok.push({
                        value: "Operator",
                        data: "<"
                    })
                    len += 1
                }
                break
            case "+":
                if (s[len + 1] == "=") {
                    state.tok.push({
                        value: "Operator",
                        data: "+="
                    })
                    len += 2
                } else if (s[len + 1] == "+") {
                    state.tok.push({
                        value: "Operator",
                        data: "++"
                    })
                    len += 2
                } else {
                    state.tok.push({
                        value: "Operator",
                        data: "+"
                    })
                    len += 1
                }
                break
            case "*":
                if (s[1] == "=") {
                    state.tok.push({
                        value: "Operator",
                        data: "*="
                    })
                    len += 2
                } else {
                    state.tok.push({
                        value: "Operator",
                        data: "*"
                    })
                    len += 1
                }
                break
            case "~":
                state.tok.push({
                    value: "Operator",
                    data: "~"
                })
                len += 1
                break
            case "%":
                state.tok.push({
                    value: "Operator",
                    data: "%"
                })
                len += 1
                break
            default:
                var js_ident = "ident"
                var i = 1
                while (matchchars.test(s.charAt(len + i))) {
                    i++
                }
                var hit = s.substr(len, i)
                if (state.keywords.has(hit)) {
                    if (this.keywordhandlers.has(hit)) {
                        len += hit.length
                        len = this.keywordhandlers.get(hit)(s, len, state)
                        continue
                    } else {
                        state.tok.push({
                            value: "keyword",
                            data: hit
                        })
                        len += hit.length
                        continue
                    }
                }
                if(hit == "success"){debugger;}
                state.tok.push({
                    value: js_ident,
                    data: hit
                });
                len += hit.length
                continue
                break
            }
        }
        return len
    }
    toString() {
        return state.tok
    }
}
if (typeof exports == "undefined") {
    parser = new parsejs();
    parser.parse(code, 0, parser.state)
} else {
    exports.parsejs = parsejs
}
