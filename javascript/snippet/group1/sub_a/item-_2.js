/* spell:words
--- version_list item 2 ---
v1 (old-o): snippet_repo_v2/javascript/final/__ret_do_cur_debugApi.js
v2 (cur-c): snippet_repo_v2/javascript/snippet/group1/sub_a/item-_2.js
*/
function raw_template(v) {
	return v.raw[0];
}
let _module_jai_content = raw_template`

// create_*...

Create_Package :: struct {
	data: String_Builder;

	entries: [..] Entry_Info;
}

init :: (using package: *Create_Package) {
}

deinit :: (using package: *Create_Package) {
	free_buffers(*data);
	array_reset(*entries);
}

add :: (package: *Create_Package, entry_name: string, data [] u8) {
}

write :: (package: *Create_Package, filename: string) -> bool {
	header: String_Builder;
	table_of_contents: String_Builder;

	// Magic number (32-bit integer):
	append(*header, MAGIC);

	put(*header, cast(u32) FILE_VERSION);

	// Flags word, 32 bits. There are no flags currently.
	// Maybe later there will be an endian flag here.
	put(*header, cast(u32) 0);

	// Offset to the tabel of contents, from the start of the file
	// (64-bit unsigned integer). We fill in 0 for now, and we will
	// back-patch it later if we are going to write as we go.

	put(*header, cast(u64) 0);  // nocheckin, fill this out.

	file, success := file_open(filename, true, false, true);
	if !success {
		log_error("In Simple_Package, unable to open '%' for writing!\n", filename);
		return false;
	}

	defer file_close(*file);

	success = file_write(*file, header);
	if !success {
		log_error("In Simple_Package, unable to write the header for file '%'\n", filename);
		return false;
	}

	success = file_write(*file, package.data);
	if !success {
		log_error("In Simple_Package, unable to write the body for file '%'\n", filename);
		return false;
	}


	//
	// Table of contents: 
	//

	// Number of files (64-bit unsigned integer):

	put(*table_of_contents, cast(u64) package.entries.count);
	for entry: package.entries {
	}

	success = file_write(*file, table_of_contents);
	if !success {
		log_error("In Simple_Package, unable to write the table of contents for file '%'\n", filename);
		return false;
	}

	return true;
}


// load_*...

Package :: struct {
}



#scope_file

MAGIC :: "simp";

FILE_VERSION :: 1;
TARGET_IS_LITTLE_ENDIAN :: true;  // @Endian: Need a way to change this based on target CPU!

// @Copypasta from the game!
put :: (builder: *String_Builder, x: $T)
#modify {
	using Type_Info_Tag;
	if T.type == INTEGER return;
	if T.type == FLOAT   return;
	if T.type == BOOL    return;
	if T.type == ENUM    return;

	T = null;
}
{
	ensure_contiguous_space(builder, size_of(T));

	#if TARGET_IS_LITTLE_ENDIAN {
		// @Speed: Just write the target type!
		simple_memcpy(builder, x);
	} else {
		// @Incomplete: Do a slow-path if we know we are not little-endian. This can be generated by #run_and_insert?
		assert(false);
	}
}
#import "Basic";
`;
