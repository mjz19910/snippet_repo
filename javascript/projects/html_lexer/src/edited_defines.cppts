#define CONSUME_NEXT_INPUT_CHARACTER \
    current_input_character = this.next_code_point();

#define SWITCH_TO(new_state)                       \
    do {                                           \
        VERIFY(this.m_current_builder.is_empty());      \
        SWITCH_TO_WITH_UNCLEAN_BUILDER(new_state); \
    } while (0)

#define SWITCH_TO_WITH_UNCLEAN_BUILDER(new_state) \
    do {                                          \
        this.will_switch_to(State.new_state);         \
        this.m_state = State.new_state;               \
        CONSUME_NEXT_INPUT_CHARACTER;              \
    } while (0)

#define RECONSUME_IN(new_state)              \
    do {                                     \
        this.will_reconsume_in(State.new_state); \
        this.m_state = State.new_state;          \
        this.m_goto_target=#new_state; \
        break _StartOfFunction;       \
    } while (0)


#define SWITCH_TO_RETURN_STATE          \
    do {                                \
        this.will_switch_to(this.m_return_state); \
        this.m_state = this.m_return_state;       \
        this.m_goto_target="_StartOfFunction";  \
        break _StartOfFunction;    \
    } while (0)

#define RECONSUME_IN_RETURN_STATE                \
    do {                                         \
        this.will_reconsume_in(this.m_return_state);       \
        this.m_state = this.m_return_state;                \
        if (current_input_character.has_value()) \
            this.restore_to(this.m_prev_utf8_iterator);    \
        this.m_goto_target="_StartOfFunction";  \
        break _StartOfFunction;    \
    } while (0)

#define SWITCH_TO_AND_EMIT_CURRENT_TOKEN(new_state)     \
    do {                                                \
        VERIFY(this.m_current_builder.is_empty());           \
        this.will_switch_to(State.new_state);               \
        this.m_state = State.new_state;                     \
        this.will_emit(this.m_current_token);                     \
        this.m_queued_tokens.enqueue(move(this.m_current_token)); \
        return this.m_queued_tokens.dequeue().opt();               \
    } while (0)

#define EMIT_CHARACTER_AND_RECONSUME_IN(code_point, new_state)          \
    do {                                                                \
        this.m_queued_tokens.enqueue(HTMLToken.make_character(code_point)); \
        this.will_reconsume_in(State.new_state);                            \
        this.m_state = State.new_state;                                     \
        this.m_goto_target=#new_state; \
        break _StartOfFunction;       \
    } while (0)

#define FLUSH_CODEPOINTS_CONSUMED_AS_A_CHARACTER_REFERENCE      \
    do {                                                        \
        for (let code_point of this.m_temporary_buffer) {            \
            if (this.consumed_as_part_of_an_attribute()) {           \
                this.m_current_builder.append_code_point(code_point);\
            } else {                                            \
                this.create_new_token(HTMLToken.Type.Character);   \
                if(!this.m_current_token) throw new Error();    \
                this.m_current_token.set_code_point(code_point);     \
                this.m_queued_tokens.enqueue(move(this.m_current_token)); \
            }                                                   \
        }                                                       \
    } while (0)

#define DONT_CONSUME_NEXT_INPUT_CHARACTER \
    this.restore_to(this.m_prev_utf8_iterator);

#define ON(code_point) \
    if (current_input_character.has_value() && current_input_character.value() == code_point)

#define ON_EOF \
    if (!current_input_character.has_value())

#define ON_ASCII_ALPHA \
    if (current_input_character.has_value() && this.is_ascii_alpha(current_input_character.value()))

#define ON_ASCII_ALPHANUMERIC \
    if (current_input_character.has_value() && this.is_ascii_alphanumeric(current_input_character.value()))

#define ON_ASCII_UPPER_ALPHA \
    if (current_input_character.has_value() && this.is_ascii_upper_alpha(current_input_character.value()))

#define ON_ASCII_LOWER_ALPHA \
    if (current_input_character.has_value() && this.is_ascii_lower_alpha(current_input_character.value()))

#define ON_ASCII_DIGIT \
    if (current_input_character.has_value() && this.is_ascii_digit(current_input_character.value()))

#define ON_ASCII_HEX_DIGIT \
    if (current_input_character.has_value() && this.is_ascii_hex_digit(current_input_character.value()))

#define ON_WHITESPACE \
    if (current_input_character.has_value() && this.is_ascii(current_input_character.value()) && "\t\n\f ".includes(String.fromCharCode(current_input_character.value())))

#define ANYTHING_ELSE if (1)

#define EMIT_EOF                                       \
    do {                                               \
        if (this.m_has_emitted_eof)                         \
            return new Optional;                      \
        this.m_has_emitted_eof = true;                      \
        this.create_new_token(HTMLToken.Type.EndOfFile);  \
        this.will_emit(this.m_current_token);                    \
        this.m_queued_tokens.enqueue(move(this.m_current_token));\
        return this.m_queued_tokens.dequeue().opt();            \
    } while (0)

#define EMIT_CURRENT_TOKEN                             \
    do {                                               \
        VERIFY(this.m_current_builder.is_empty());          \
        this.will_emit(this.m_current_token);                    \
        this.m_queued_tokens.enqueue(move(this.m_current_token));\
        return this.m_queued_tokens.dequeue().opt();              \
    } while (0)

#define EMIT_CHARACTER(code_point)                     \
    do {                                               \
        this.create_new_token(HTMLToken.Type.Character);<line>\
        if(!this.m_current_token) throw new Error();  \
        this.m_current_token.set_code_point(code_point);    \
        this.m_queued_tokens.enqueue(move(this.m_current_token));\
        return this.m_queued_tokens.dequeue().opt();              \
    } while (0)

#define EMIT_CURRENT_CHARACTER\
    EMIT_CHARACTER(current_input_character.value());

#define SWITCH_TO_AND_EMIT_CHARACTER(code_point, new_state)\
    do {                                                   \
        this.will_switch_to(State.new_state);                  \
        this.m_state = State.new_state;                        \
        EMIT_CHARACTER(code_point);                        \
    } while (0)

#define SWITCH_TO_AND_EMIT_CURRENT_CHARACTER(new_state)\
    SWITCH_TO_AND_EMIT_CHARACTER(current_input_character.value(), new_state)

#define BEGIN_STATE(state)\
    /*<csw>state:</csw>*/<line>\
    case State.state: {  \
        {                 \
            { <line>

#define END_STATE        \
    VERIFY_NOT_REACHED();\
    break;               \
    }                    \
    }                    \
    }
